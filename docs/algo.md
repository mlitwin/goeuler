<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# algo

```go
import "github.com/mlitwin/goeuler/algo"
```

Package algo comprises algorithms conceptually more complicated than those in package arith These will generally be graph theoretical\, sorting and searching\, etc\.\, rather than more conceptually arithmetic ones\. algo can use arith\, but not conversely\.

## Index

- [func BubbleSort(input []int)](<#func-bubblesort>)
- [func CountSort[T any](a []T, bucket func(T) int, bucketCount int)](<#func-countsort>)
- [func InsertionSort(input []int)](<#func-insertionsort>)
- [func MergeSortBottomUp(a []int)](<#func-mergesortbottomup>)
- [func MergeSortTopDown(a []int)](<#func-mergesorttopdown>)
- [func MinPathAStar[V any, ID comparable, W Numeric](g AStarGraph[V, ID, W], start *V, end *V) (W, []*V)](<#func-minpathastar>)
- [func QuicksortHoar(a []int)](<#func-quicksorthoar>)
- [func QuicksortLomuto(a []int)](<#func-quicksortlomuto>)
- [func QuicksortLomutoDutchFlag(a []int)](<#func-quicksortlomutodutchflag>)
- [func RadixSort(a []int)](<#func-radixsort>)
- [func SelectionSort(input []int)](<#func-selectionsort>)
- [type AStarGraph](<#type-astargraph>)
- [type CycleDetector](<#type-cycledetector>)
  - [func NewCycleDetector(start CycleNode) *CycleDetector](<#func-newcycledetector>)
  - [func (d *CycleDetector) FindCycleFlyod()](<#func-cycledetector-findcycleflyod>)
  - [func (d *CycleDetector) FindCycleStart() int64](<#func-cycledetector-findcyclestart>)
  - [func (d *CycleDetector) FindMinCycle() int64](<#func-cycledetector-findmincycle>)
- [type CycleNode](<#type-cyclenode>)
- [type FenwickTree](<#type-fenwicktree>)
  - [func NewFenwickTree(highIndex int64) *FenwickTree](<#func-newfenwicktree>)
  - [func (f FenwickTree) Debug()](<#func-fenwicktree-debug>)
  - [func (f FenwickTree) Read(idx int64) (ret int64)](<#func-fenwicktree-read>)
  - [func (f *FenwickTree) Update(idx int64, val int64)](<#func-fenwicktree-update>)
- [type Heap](<#type-heap>)
  - [func NewHeap[V any, P Numeric]() *Heap[V, P]](<#func-newheap>)
  - [func (h *Heap[V, P]) Decrease(n *HeapNode[V, P], priority P)](<#func-heapv-p-decrease>)
  - [func (h *Heap[V, P]) Len() int](<#func-heapv-p-len>)
  - [func (h *Heap[V, P]) Pop() *HeapNode[V, P]](<#func-heapv-p-pop>)
  - [func (h *Heap[V, P]) Push(x V, priority P) *HeapNode[V, P]](<#func-heapv-p-push>)
  - [func (h *Heap[V, P]) Upsert(x V, priority P, n *HeapNode[V, P]) *HeapNode[V, P]](<#func-heapv-p-upsert>)
  - [func (h *Heap[V, P]) Validate() bool](<#func-heapv-p-validate>)
- [type HeapNode](<#type-heapnode>)
- [type Numeric](<#type-numeric>)


## func BubbleSort

```go
func BubbleSort(input []int)
```

## func CountSort

```go
func CountSort[T any](a []T, bucket func(T) int, bucketCount int)
```

## func InsertionSort

```go
func InsertionSort(input []int)
```

## func MergeSortBottomUp

```go
func MergeSortBottomUp(a []int)
```

## func MergeSortTopDown

```go
func MergeSortTopDown(a []int)
```

## func MinPathAStar

```go
func MinPathAStar[V any, ID comparable, W Numeric](g AStarGraph[V, ID, W], start *V, end *V) (W, []*V)
```

## func QuicksortHoar

```go
func QuicksortHoar(a []int)
```

## func QuicksortLomuto

```go
func QuicksortLomuto(a []int)
```

## func QuicksortLomutoDutchFlag

```go
func QuicksortLomutoDutchFlag(a []int)
```

## func RadixSort

```go
func RadixSort(a []int)
```

## func SelectionSort

```go
func SelectionSort(input []int)
```

## type AStarGraph

AStarGraph defines the interface needed by the caller They need a graph object which traffics in verticies\. In order to be able to store auxilliary information about verticies there also needs to be a comparable vertex ID

A \`MinPathAStar\[V any\, ID comparable\, W Numeric\]\(g AStarGraph\[V\,ID\,W\]\, start \*V\, end \*V\) \(W\, \[\]\*V\) \` function\. Takes an \`AStarGraph\`\, start and end vertex\, returns the min weight\, and the path\.

An interesting design question here is how to handle the auxiliary data the algorithm needs to store about each vertex\. Here we require the \`AStarGraph\` interface to be able to give a comparable \`ID\` for each vertex\, so the algorithm can use that as a key to an \(internal\) map\.

Another way to go would be to require the \`AStarGraph\` to be able to store \(and produce\) the auxiliary data itself\. It seemed like most implementation would end up with some kind of map anyway\, which is why I didn't go this route\.

```go
type AStarGraph[V any, ID comparable, W Numeric] interface {
    GetId(v *V) ID
    Heuristic(v *V) W
    Visit(v *V, visit func(neighbor *V, weight W))
}
```

## type CycleDetector

```go
type CycleDetector struct {
    Start    CycleNode
    Tortice  CycleNode
    Hare     CycleNode
    Distance int64
}
```

### func NewCycleDetector

```go
func NewCycleDetector(start CycleNode) *CycleDetector
```

### func \(\*CycleDetector\) FindCycleFlyod

```go
func (d *CycleDetector) FindCycleFlyod()
```

Advance to a cycle multiple

### func \(\*CycleDetector\) FindCycleStart

```go
func (d *CycleDetector) FindCycleStart() int64
```

At a cycle ? Find where cycling starts

### func \(\*CycleDetector\) FindMinCycle

```go
func (d *CycleDetector) FindMinCycle() int64
```

At a cycle multiple? Find the min period

## type CycleNode

```go
type CycleNode interface {
    Advance() // ++
    Equals(c interface{}) bool
    Assign(c interface{}) // Set this to c
    Clone() CycleNode     // Return a copy

}
```

## type FenwickTree

```go
type FenwickTree struct {
    // contains filtered or unexported fields
}
```

### func NewFenwickTree

```go
func NewFenwickTree(highIndex int64) *FenwickTree
```

### func \(FenwickTree\) Debug

```go
func (f FenwickTree) Debug()
```

### func \(FenwickTree\) Read

```go
func (f FenwickTree) Read(idx int64) (ret int64)
```

### func \(\*FenwickTree\) Update

```go
func (f *FenwickTree) Update(idx int64, val int64)
```

## type Heap

A min \`Heap\[V any\, P Numeric\] \`\, supporting a \`Decrease\(\)\` operation

```go
type Heap[V any, P Numeric] struct {
    // contains filtered or unexported fields
}
```

### func NewHeap

```go
func NewHeap[V any, P Numeric]() *Heap[V, P]
```

### func \(\*Heap\[V\, P\]\) Decrease

```go
func (h *Heap[V, P]) Decrease(n *HeapNode[V, P], priority P)
```

### func \(\*Heap\[V\, P\]\) Len

```go
func (h *Heap[V, P]) Len() int
```

### func \(\*Heap\[V\, P\]\) Pop

```go
func (h *Heap[V, P]) Pop() *HeapNode[V, P]
```

### func \(\*Heap\[V\, P\]\) Push

```go
func (h *Heap[V, P]) Push(x V, priority P) *HeapNode[V, P]
```

### func \(\*Heap\[V\, P\]\) Upsert

```go
func (h *Heap[V, P]) Upsert(x V, priority P, n *HeapNode[V, P]) *HeapNode[V, P]
```

Convenience fucnction to Push if new\, change priority if exists

### func \(\*Heap\[V\, P\]\) Validate

```go
func (h *Heap[V, P]) Validate() bool
```

## type HeapNode

```go
type HeapNode[V any, P Numeric] struct {
    // contains filtered or unexported fields
}
```

## type Numeric

```go
type Numeric interface {
    // contains filtered or unexported methods
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
