<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# algo

```go
import "github.com/mlitwin/goeuler/algo"
```

Package algo comprises algorithms conceptually more complicated than those in package arith These will generally be graph theoretical\, sorting and searching\, etc\.\, rather than more conceptually arithmetic ones\. algo can use arith\, but not conversely\.

## Index

- [func BubbleSort(input []int)](<#func-bubblesort>)
- [func CountSort[T any](a []T, bucket func(T) int, bucketCount int)](<#func-countsort>)
- [func InsertionSort(input []int)](<#func-insertionsort>)
- [func MergeSortBottomUp(a []int)](<#func-mergesortbottomup>)
- [func MergeSortTopDown(a []int)](<#func-mergesorttopdown>)
- [func MinPathAStar[ID comparable, W Numeric](g AStarGraph[ID, W], start ID, end ID) (W, []ID)](<#func-minpathastar>)
- [func QuicksortHoar(a []int)](<#func-quicksorthoar>)
- [func QuicksortLomuto(a []int)](<#func-quicksortlomuto>)
- [func QuicksortLomutoDutchFlag(a []int)](<#func-quicksortlomutodutchflag>)
- [func RadixSort(a []int)](<#func-radixsort>)
- [func SelectionSort(input []int)](<#func-selectionsort>)
- [type AStarGraph](<#type-astargraph>)
- [type CycleDetector](<#type-cycledetector>)
  - [func NewCycleDetector(start CycleNode) *CycleDetector](<#func-newcycledetector>)
  - [func (d *CycleDetector) FindCycleFlyod()](<#func-cycledetector-findcycleflyod>)
  - [func (d *CycleDetector) FindCycleStart() int64](<#func-cycledetector-findcyclestart>)
  - [func (d *CycleDetector) FindMinCycle() int64](<#func-cycledetector-findmincycle>)
- [type CycleNode](<#type-cyclenode>)
- [type FenwickTree](<#type-fenwicktree>)
  - [func NewFenwickTree(highIndex int64) *FenwickTree](<#func-newfenwicktree>)
  - [func (f FenwickTree) Debug()](<#func-fenwicktree-debug>)
  - [func (f FenwickTree) Read(idx int64) (ret int64)](<#func-fenwicktree-read>)
  - [func (f *FenwickTree) Update(idx int64, val int64)](<#func-fenwicktree-update>)
- [type GridDag](<#type-griddag>)
  - [func NewGridDag(m [][]int64) *GridDag](<#func-newgriddag>)
  - [func (g *GridDag) AddEdge(i0, j0 int, i1, j1 int)](<#func-griddag-addedge>)
  - [func (g *GridDag) AddVertex(i, j int, w int64)](<#func-griddag-addvertex>)
  - [func (g GridDag) Heuristic(v GridIndex) int64](<#func-griddag-heuristic>)
  - [func (g GridDag) MinPathAStar(i0, j0 int, i1, j1 int) (int64, []GridIndex)](<#func-griddag-minpathastar>)
  - [func (g GridDag) Visit(v GridIndex, visit func(neighbor GridIndex, weight int64))](<#func-griddag-visit>)
  - [func (g GridDag) VisitAllNeighbors(visit func(i0, j0 int, i1, j1 int))](<#func-griddag-visitallneighbors>)
- [type GridIndex](<#type-gridindex>)
- [type Heap](<#type-heap>)
  - [func NewHeap[V any, P Numeric]() *Heap[V, P]](<#func-newheap>)
  - [func (h *Heap[V, P]) Decrease(n *HeapNode[V, P], priority P)](<#func-heapv-p-decrease>)
  - [func (h *Heap[V, P]) Len() int](<#func-heapv-p-len>)
  - [func (h *Heap[V, P]) Pop() *HeapNode[V, P]](<#func-heapv-p-pop>)
  - [func (h *Heap[V, P]) Push(x V, priority P) *HeapNode[V, P]](<#func-heapv-p-push>)
  - [func (h *Heap[V, P]) Upsert(x V, priority P, n *HeapNode[V, P]) *HeapNode[V, P]](<#func-heapv-p-upsert>)
  - [func (h *Heap[V, P]) Validate() bool](<#func-heapv-p-validate>)
- [type HeapNode](<#type-heapnode>)
- [type Numeric](<#type-numeric>)


## func BubbleSort

```go
func BubbleSort(input []int)
```

## func CountSort

```go
func CountSort[T any](a []T, bucket func(T) int, bucketCount int)
```

## func InsertionSort

```go
func InsertionSort(input []int)
```

## func MergeSortBottomUp

```go
func MergeSortBottomUp(a []int)
```

## func MergeSortTopDown

```go
func MergeSortTopDown(a []int)
```

## func MinPathAStar

```go
func MinPathAStar[ID comparable, W Numeric](g AStarGraph[ID, W], start ID, end ID) (W, []ID)
```

## func QuicksortHoar

```go
func QuicksortHoar(a []int)
```

## func QuicksortLomuto

```go
func QuicksortLomuto(a []int)
```

## func QuicksortLomutoDutchFlag

```go
func QuicksortLomutoDutchFlag(a []int)
```

## func RadixSort

```go
func RadixSort(a []int)
```

## func SelectionSort

```go
func SelectionSort(input []int)
```

## type AStarGraph

AStarGraph defines the interface needed by the caller They need a graph object which traffics in vertex id's\, which need to be comparable in  order to be able to store auxilliary information about vertices\.

A \`MinPathAStar\[ID comparable\, W Numeric\]\(g AStarGraph\[ID\,W\]\, start ID\, end ID\) \(W\, \[\]ID\) \` function\. Takes an \`AStarGraph\`\, start and end vertex\, returns the min weight\, and the path\.

An interesting design question here is how to handle the auxiliary data the algorithm needs to store about each vertex\. Here we require the \`AStarGraph\` interface to traffic with a comparable \`ID\` for each vertex\, so the algorithm can use that as a key to an \(internal\) map\.

Another way to go would be to require the \`AStarGraph\` to be able to store \(and produce\) the auxiliary data itself\. It seemed like most implementation would end up with some kind of map anyway\, which is why I didn't go this route\.

```go
type AStarGraph[ID comparable, W Numeric] interface {
    Heuristic(v ID) W
    Visit(v ID, visit func(neighbor ID, weight W))
}
```

## type CycleDetector

```go
type CycleDetector struct {
    Start    CycleNode
    Tortice  CycleNode
    Hare     CycleNode
    Distance int64
}
```

### func NewCycleDetector

```go
func NewCycleDetector(start CycleNode) *CycleDetector
```

### func \(\*CycleDetector\) FindCycleFlyod

```go
func (d *CycleDetector) FindCycleFlyod()
```

Advance to a cycle multiple

### func \(\*CycleDetector\) FindCycleStart

```go
func (d *CycleDetector) FindCycleStart() int64
```

At a cycle ? Find where cycling starts

### func \(\*CycleDetector\) FindMinCycle

```go
func (d *CycleDetector) FindMinCycle() int64
```

At a cycle multiple? Find the min period

## type CycleNode

```go
type CycleNode interface {
    Advance() // ++
    Equals(c interface{}) bool
    Assign(c interface{}) // Set this to c
    Clone() CycleNode     // Return a copy

}
```

## type FenwickTree

```go
type FenwickTree struct {
    // contains filtered or unexported fields
}
```

### func NewFenwickTree

```go
func NewFenwickTree(highIndex int64) *FenwickTree
```

### func \(FenwickTree\) Debug

```go
func (f FenwickTree) Debug()
```

### func \(FenwickTree\) Read

```go
func (f FenwickTree) Read(idx int64) (ret int64)
```

### func \(\*FenwickTree\) Update

```go
func (f *FenwickTree) Update(idx int64, val int64)
```

## type GridDag

Generic Graph / DAG based on a grid

```go
type GridDag struct {
    // contains filtered or unexported fields
}
```

### func NewGridDag

```go
func NewGridDag(m [][]int64) *GridDag
```

### func \(\*GridDag\) AddEdge

```go
func (g *GridDag) AddEdge(i0, j0 int, i1, j1 int)
```

### func \(\*GridDag\) AddVertex

```go
func (g *GridDag) AddVertex(i, j int, w int64)
```

### func \(GridDag\) Heuristic

```go
func (g GridDag) Heuristic(v GridIndex) int64
```

Generic Graph interface \- here the index is the same type as the vertex

### func \(GridDag\) MinPathAStar

```go
func (g GridDag) MinPathAStar(i0, j0 int, i1, j1 int) (int64, []GridIndex)
```

### func \(GridDag\) Visit

```go
func (g GridDag) Visit(v GridIndex, visit func(neighbor GridIndex, weight int64))
```

### func \(GridDag\) VisitAllNeighbors

```go
func (g GridDag) VisitAllNeighbors(visit func(i0, j0 int, i1, j1 int))
```

Convenience utility to visit the potential neighbors of verticies

## type GridIndex

```go
type GridIndex struct {
    I, J int
}
```

## type Heap

A min \`Heap\[V any\, P Numeric\] \`\, supporting a \`Decrease\(\)\` operation

```go
type Heap[V any, P Numeric] struct {
    // contains filtered or unexported fields
}
```

### func NewHeap

```go
func NewHeap[V any, P Numeric]() *Heap[V, P]
```

### func \(\*Heap\[V\, P\]\) Decrease

```go
func (h *Heap[V, P]) Decrease(n *HeapNode[V, P], priority P)
```

### func \(\*Heap\[V\, P\]\) Len

```go
func (h *Heap[V, P]) Len() int
```

### func \(\*Heap\[V\, P\]\) Pop

```go
func (h *Heap[V, P]) Pop() *HeapNode[V, P]
```

### func \(\*Heap\[V\, P\]\) Push

```go
func (h *Heap[V, P]) Push(x V, priority P) *HeapNode[V, P]
```

### func \(\*Heap\[V\, P\]\) Upsert

```go
func (h *Heap[V, P]) Upsert(x V, priority P, n *HeapNode[V, P]) *HeapNode[V, P]
```

Convenience fucnction to Push if new\, change priority if exists

### func \(\*Heap\[V\, P\]\) Validate

```go
func (h *Heap[V, P]) Validate() bool
```

## type HeapNode

```go
type HeapNode[V any, P Numeric] struct {
    // contains filtered or unexported fields
}
```

## type Numeric

```go
type Numeric interface {
    // contains filtered or unexported methods
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
