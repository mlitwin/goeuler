<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# arith

```go
import "github.com/mlitwin/goeuler/arith"
```

## Index

- [Constants](<#constants>)
- [func C(n int64, k int64) int64](<#func-c>)
- [func Digits(n int64, b int64) []int64](<#func-digits>)
- [func GCD(a, b int64) int64](<#func-gcd>)
- [func HistogramOfDigits(n []int64, b int64) []int64](<#func-histogramofdigits>)
- [func IntSolveQuadradic(a, b, c int64) (ret []int64)](<#func-intsolvequadradic>)
- [func IntSqrt(n int64) int64](<#func-intsqrt>)
- [func InverseModN(a, n int64) int64](<#func-inversemodn>)
- [func IsPrime(x int64) bool](<#func-isprime>)
- [func LCM(a, b int64) int64](<#func-lcm>)
- [func NewRationalSurd(D int64) (*RationalSurd, *RationalSurdValue)](<#func-newrationalsurd>)
- [func NextCFConvergentOf[V any](s *RationalSurd, i Integer[V], cur []V, a int64) []V](<#func-nextcfconvergentof>)
- [func NormalizeDigits(n []int64, b int64) []int64](<#func-normalizedigits>)
- [func Pow(x int64, n int64) int64](<#func-pow>)
- [func PowOf[V any](f Integer[V], x V, n int64) V](<#func-powof>)
- [func Reduce(i Iterator, f func(int64, int64) int64, start int64) int64](<#func-reduce>)
- [func Totient(n int64) int64](<#func-totient>)
- [func ValueOfDigits(n []int64, b int64) (ret int64)](<#func-valueofdigits>)
- [type DigitList](<#type-digitlist>)
  - [func NewDigitList(base int64) *DigitList](<#func-newdigitlist>)
  - [func (d DigitList) Cmp(a []int64, b []int64) int](<#func-digitlist-cmp>)
  - [func (d DigitList) Diff(x *[]int64, a []int64, b []int64)](<#func-digitlist-diff>)
  - [func (d DigitList) Digits(n int64) []int64](<#func-digitlist-digits>)
  - [func (d DigitList) Div(x *[]int64, a []int64, b []int64)](<#func-digitlist-div>)
  - [func (d DigitList) Let(x *[]int64, a int64)](<#func-digitlist-let>)
  - [func (d DigitList) Mul(x *[]int64, a []int64, b []int64)](<#func-digitlist-mul>)
  - [func (d DigitList) Neg(x *[]int64, a []int64)](<#func-digitlist-neg>)
  - [func (d DigitList) Set(x *[]int64, a []int64)](<#func-digitlist-set>)
  - [func (d DigitList) Sum(x *[]int64, a []int64, b []int64)](<#func-digitlist-sum>)
  - [func (d DigitList) ValueOfDigits(n []int64) (ret int64)](<#func-digitlist-valueofdigits>)
- [type Divisors](<#type-divisors>)
  - [func NewDivisors(n int64) *Divisors](<#func-newdivisors>)
  - [func (d *Divisors) HasValue() bool](<#func-divisors-hasvalue>)
  - [func (d *Divisors) NextValue() int64](<#func-divisors-nextvalue>)
- [type Factoradic](<#type-factoradic>)
  - [func NewFactoradic(n int64) *Factoradic](<#func-newfactoradic>)
  - [func (f Factoradic) Permutation(n int64) []int64](<#func-factoradic-permutation>)
- [type IntModM](<#type-intmodm>)
  - [func NewIntModM(m int64) *IntModM](<#func-newintmodm>)
  - [func (m IntModM) Cmp(a int64, b int64) int](<#func-intmodm-cmp>)
  - [func (m IntModM) Diff(x *int64, a int64, b int64)](<#func-intmodm-diff>)
  - [func (m IntModM) Div(x *int64, a int64, b int64)](<#func-intmodm-div>)
  - [func (m IntModM) Let(x *int64, a int64)](<#func-intmodm-let>)
  - [func (m IntModM) Mul(x *int64, a int64, b int64)](<#func-intmodm-mul>)
  - [func (m IntModM) Neg(x *int64, a int64)](<#func-intmodm-neg>)
  - [func (m IntModM) Set(x *int64, a int64)](<#func-intmodm-set>)
  - [func (m IntModM) Sum(x *int64, a int64, b int64)](<#func-intmodm-sum>)
- [type Integer](<#type-integer>)
- [type Iterator](<#type-iterator>)
- [type PrimeFactorization](<#type-primefactorization>)
  - [func NewPrimeFactorization(n int64) *PrimeFactorization](<#func-newprimefactorization>)
  - [func (f PrimeFactorization) HasValue() bool](<#func-primefactorization-hasvalue>)
  - [func (f *PrimeFactorization) NextValue() (int64, int64)](<#func-primefactorization-nextvalue>)
- [type RationalFraction](<#type-rationalfraction>)
  - [func NewRationalFraction(a int64, b int64) *RationalFraction](<#func-newrationalfraction>)
  - [func (r *RationalFraction) NextMantissaDigit(base int64) int64](<#func-rationalfraction-nextmantissadigit>)
- [type RationalSurd](<#type-rationalsurd>)
  - [func (s *RationalSurd) IntFloor(d *RationalSurdValue) int64](<#func-rationalsurd-intfloor>)
  - [func (s *RationalSurd) Invert(d *RationalSurdValue)](<#func-rationalsurd-invert>)
  - [func (s *RationalSurd) NextCFConvergent(cur []RationalFraction, a int64) []RationalFraction](<#func-rationalsurd-nextcfconvergent>)
  - [func (s *RationalSurd) NextCFTerm(d *RationalSurdValue) int64](<#func-rationalsurd-nextcfterm>)
- [type RationalSurdValue](<#type-rationalsurdvalue>)


## Constants

```go
const MaxInt64 int64 = int64((^uint64(0)) >> 1)
```

```go
const MaxSqrtInt64 int64 = 3037000499
```

```go
const MaxSquareInt64 int64 = MaxSqrtInt64 * MaxSqrtInt64
```

## func C

```go
func C(n int64, k int64) int64
```

n Choose k https://cp-algorithms.com/combinatorics/binomial-coefficients.html

## func Digits

```go
func Digits(n int64, b int64) []int64
```

### Return the digits of n base b as a slice

Deprecated: Use DigitsList

## func GCD

```go
func GCD(a, b int64) int64
```

## func HistogramOfDigits

```go
func HistogramOfDigits(n []int64, b int64) []int64
```

### Count digits in a slice

Deprecated: Do it by self

## func IntSolveQuadradic

```go
func IntSolveQuadradic(a, b, c int64) (ret []int64)
```

Return integer roots of \`ax^2\+bx\+c\` as a slice\, largest root first

## func IntSqrt

```go
func IntSqrt(n int64) int64
```

https://en.wikipedia.org/wiki/Integer_square_root

## func InverseModN

```go
func InverseModN(a, n int64) int64
```

Modular inverse \(or 0 if no inverse\)

## func IsPrime

```go
func IsPrime(x int64) bool
```

Basic primality test

## func LCM

```go
func LCM(a, b int64) int64
```

## func NewRationalSurd

```go
func NewRationalSurd(D int64) (*RationalSurd, *RationalSurdValue)
```

## func NextCFConvergentOf

```go
func NextCFConvergentOf[V any](s *RationalSurd, i Integer[V], cur []V, a int64) []V
```

Generic Next convergent: input is Integer slce \[p0\,q0\,p1\,q1\]

## func NormalizeDigits

```go
func NormalizeDigits(n []int64, b int64) []int64
```

Return the base b digit list n as a proper base b number\, each digit in range\, and no leading zeros\.

Deprecated: Use DigitsList

## func Pow

```go
func Pow(x int64, n int64) int64
```

https://en.wikipedia.org/wiki/Exponentiation_by_squaring

## func PowOf

```go
func PowOf[V any](f Integer[V], x V, n int64) V
```

Generic Pow\(\) function for an Integer\[V\] interface

## func Reduce

```go
func Reduce(i Iterator, f func(int64, int64) int64, start int64) int64
```

A generic \`Reduce\(\)\` to int64 method for Iterator's

## func Totient

```go
func Totient(n int64) int64
```

## func ValueOfDigits

```go
func ValueOfDigits(n []int64, b int64) (ret int64)
```

### Convert digit slice back to \`int64\`

Deprecated: Use DigitsList

## type DigitList

### Manage integers as lists of digits with a given base

Conforms to Integer interface

```go
type DigitList struct {
    // contains filtered or unexported fields
}
```

### func NewDigitList

```go
func NewDigitList(base int64) *DigitList
```

Constructor for DigitList

### func \(DigitList\) Cmp

```go
func (d DigitList) Cmp(a []int64, b []int64) int
```

Comparison: a X b \(\-1 means \<; 0 means ==; 1 means \>\)

### func \(DigitList\) Diff

```go
func (d DigitList) Diff(x *[]int64, a []int64, b []int64)
```

x = a \- b

### func \(DigitList\) Digits

```go
func (d DigitList) Digits(n int64) []int64
```

Create digit list representation of n\.

### func \(DigitList\) Div

```go
func (d DigitList) Div(x *[]int64, a []int64, b []int64)
```

x = a / b \(integer division\)

BUG\(mlitwin\): Not actually implemented\.

### func \(DigitList\) Let

```go
func (d DigitList) Let(x *[]int64, a int64)
```

x = a \(int64\)

### func \(DigitList\) Mul

```go
func (d DigitList) Mul(x *[]int64, a []int64, b []int64)
```

x = a \* b

### func \(DigitList\) Neg

```go
func (d DigitList) Neg(x *[]int64, a []int64)
```

x = \-a

### func \(DigitList\) Set

```go
func (d DigitList) Set(x *[]int64, a []int64)
```

x = a

### func \(DigitList\) Sum

```go
func (d DigitList) Sum(x *[]int64, a []int64, b []int64)
```

x = a \+ b

### func \(DigitList\) ValueOfDigits

```go
func (d DigitList) ValueOfDigits(n []int64) (ret int64)
```

Compute integer value represented by list of digits\.

## type Divisors

Divisors implements an Iterator through the divisors of n

```go
type Divisors struct {
    // contains filtered or unexported fields
}
```

### func NewDivisors

```go
func NewDivisors(n int64) *Divisors
```

### func \(\*Divisors\) HasValue

```go
func (d *Divisors) HasValue() bool
```

### func \(\*Divisors\) NextValue

```go
func (d *Divisors) NextValue() int64
```

## type Factoradic

A factoradic base number\, supporting conversion to a permutation\. https://en.wikipedia.org/wiki/Factorial_number_system

```go
type Factoradic struct {
    Value  int64
    Digits []int64
}
```

### func NewFactoradic

```go
func NewFactoradic(n int64) *Factoradic
```

### func \(Factoradic\) Permutation

```go
func (f Factoradic) Permutation(n int64) []int64
```

## type IntModM

Integer Modulo m\, represented in an int64

```go
type IntModM struct {
    // contains filtered or unexported fields
}
```

### func NewIntModM

```go
func NewIntModM(m int64) *IntModM
```

### func \(IntModM\) Cmp

```go
func (m IntModM) Cmp(a int64, b int64) int
```

### func \(IntModM\) Diff

```go
func (m IntModM) Diff(x *int64, a int64, b int64)
```

### func \(IntModM\) Div

```go
func (m IntModM) Div(x *int64, a int64, b int64)
```

### func \(IntModM\) Let

```go
func (m IntModM) Let(x *int64, a int64)
```

### func \(IntModM\) Mul

```go
func (m IntModM) Mul(x *int64, a int64, b int64)
```

### func \(IntModM\) Neg

```go
func (m IntModM) Neg(x *int64, a int64)
```

### func \(IntModM\) Set

```go
func (m IntModM) Set(x *int64, a int64)
```

### func \(IntModM\) Sum

```go
func (m IntModM) Sum(x *int64, a int64, b int64)
```

## type Integer

generic "Integer" operations Not a mathematics integer\, but a computer science integer \- basically has addition/subtraction/multiplication/divistion

```go
type Integer[V any] interface {
    Let(x *V, a int64)
    Set(x *V, a V)
    Neg(x *V, a V)
    Sum(x *V, a V, b V)
    Diff(x *V, a V, b V)
    Mul(x *V, a V, b V)
    Div(x *V, a V, b V)
    Cmp(a V, b V) int
}
```

## type Iterator

Basic abstract iterator of int64's with a \`HasValue\(\)\` / \`NextValue\(\)\` interface

```go
type Iterator interface {
    HasValue() bool
    NextValue() int64
}
```

## type PrimeFactorization

```go
type PrimeFactorization struct {
    // contains filtered or unexported fields
}
```

### func NewPrimeFactorization

```go
func NewPrimeFactorization(n int64) *PrimeFactorization
```

### func \(PrimeFactorization\) HasValue

```go
func (f PrimeFactorization) HasValue() bool
```

### func \(\*PrimeFactorization\) NextValue

```go
func (f *PrimeFactorization) NextValue() (int64, int64)
```

## type RationalFraction

A RationalFraction A/B supporting extraction of arbitrary base \`NextMantissaDigit\(\)\`

```go
type RationalFraction struct {
    A   int64
    B   int64
}
```

### func NewRationalFraction

```go
func NewRationalFraction(a int64, b int64) *RationalFraction
```

### func \(\*RationalFraction\) NextMantissaDigit

```go
func (r *RationalFraction) NextMantissaDigit(base int64) int64
```

Assuming proper fraction\, spit out the next digit base whatever\, and advance to to remainder

## type RationalSurd

Operations on \(a\+b\*sqrt\(D\)\)/c

```go
type RationalSurd struct {
    D int64 // surd
    // contains filtered or unexported fields
}
```

### func \(\*RationalSurd\) IntFloor

```go
func (s *RationalSurd) IntFloor(d *RationalSurdValue) int64
```

floor\(d\)

### func \(\*RationalSurd\) Invert

```go
func (s *RationalSurd) Invert(d *RationalSurdValue)
```

1/d

### func \(\*RationalSurd\) NextCFConvergent

```go
func (s *RationalSurd) NextCFConvergent(cur []RationalFraction, a int64) []RationalFraction
```

Next convergent for continued fraction start with an empty \[\]RationalFraction slice\. Convergent will be the last in the returned slice\. Slice is kept for recurrence relation\.

### func \(\*RationalSurd\) NextCFTerm

```go
func (s *RationalSurd) NextCFTerm(d *RationalSurdValue) int64
```

Next term in continued fraction

## type RationalSurdValue

Instance of \(a\+b\*sqrt\(D\)\)/c

```go
type RationalSurdValue struct {
    // contains filtered or unexported fields
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
