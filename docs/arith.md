<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# arith

```go
import "github.com/mlitwin/goeuler/arith"
```

The \`arith\` package has lower\-level entities and functions not rising to the level of an algorithm\. This is admittedly a somewhat arbitrary distinction\, but is intended to be a set of primitives for use in \(more complicated\) algorithms in the algo package\.

The general type used for integers is \`int64\`\, since Project Euler generally keeps itself to problems that basically fit into a 32 bit integer\. Using 64 bits leaves you room for to do some basic calculations allowing some intermediate results which would overflow in 32 bits\.

## Index

- [Constants](<#constants>)
- [func C(n int64, k int64) int64](<#func-c>)
- [func GCD(a, b int64) int64](<#func-gcd>)
- [func IntSolveQuadradic(a, b, c int64) (ret []int64)](<#func-intsolvequadradic>)
- [func IntSqrt(n int64) int64](<#func-intsqrt>)
- [func InverseModN(a, n int64) int64](<#func-inversemodn>)
- [func IsPrime(x int64) bool](<#func-isprime>)
- [func LCM(a, b int64) int64](<#func-lcm>)
- [func NewRationalSurd(D int64) (*RationalSurd, *RationalSurdValue)](<#func-newrationalsurd>)
- [func NextCFConvergentOf[V any](i Integer[V], cur []V, a V) []V](<#func-nextcfconvergentof>)
- [func Pow(x int64, n int64) int64](<#func-pow>)
- [func PowOf[V any](f Integer[V], x V, n int64) V](<#func-powof>)
- [func Reduce(i Iterator, f func(int64, int64) int64, start int64) int64](<#func-reduce>)
- [func Totient(n int64) int64](<#func-totient>)
- [type BigInt](<#type-bigint>)
  - [func NewBigInt() *BigInt](<#func-newbigint>)
  - [func (bv BigInt) Cmp(a big.Int, b big.Int) int](<#func-bigint-cmp>)
  - [func (bb BigInt) Diff(x *big.Int, a big.Int, b big.Int)](<#func-bigint-diff>)
  - [func (bb BigInt) Div(x *big.Int, a big.Int, b big.Int)](<#func-bigint-div>)
  - [func (b BigInt) Let(x *big.Int, a int64)](<#func-bigint-let>)
  - [func (bb BigInt) Mul(x *big.Int, a big.Int, b big.Int)](<#func-bigint-mul>)
  - [func (b BigInt) Neg(x *big.Int, a big.Int)](<#func-bigint-neg>)
  - [func (b BigInt) Set(x *big.Int, a big.Int)](<#func-bigint-set>)
  - [func (bb BigInt) Sum(x *big.Int, a big.Int, b big.Int)](<#func-bigint-sum>)
- [type Combinations](<#type-combinations>)
  - [func NewCombinations(n, k int64) *Combinations](<#func-newcombinations>)
  - [func (c *Combinations) GetValue() []int64](<#func-combinations-getvalue>)
  - [func (c *Combinations) HasValue() bool](<#func-combinations-hasvalue>)
  - [func (c *Combinations) NextValue()](<#func-combinations-nextvalue>)
- [type DigitList](<#type-digitlist>)
  - [func NewDigitList(base int64) *DigitList](<#func-newdigitlist>)
  - [func (d DigitList) Cmp(a []int64, b []int64) int](<#func-digitlist-cmp>)
  - [func (d DigitList) Diff(x *[]int64, a []int64, b []int64)](<#func-digitlist-diff>)
  - [func (d DigitList) Digits(n int64) []int64](<#func-digitlist-digits>)
  - [func (d DigitList) Div(x *[]int64, a []int64, b []int64)](<#func-digitlist-div>)
  - [func (d DigitList) Histogram(n []int64) (ret []int64)](<#func-digitlist-histogram>)
  - [func (d DigitList) Let(x *[]int64, a int64)](<#func-digitlist-let>)
  - [func (d DigitList) Mul(x *[]int64, a []int64, b []int64)](<#func-digitlist-mul>)
  - [func (d DigitList) Neg(x *[]int64, a []int64)](<#func-digitlist-neg>)
  - [func (d DigitList) Set(x *[]int64, a []int64)](<#func-digitlist-set>)
  - [func (d DigitList) Sum(x *[]int64, a []int64, b []int64)](<#func-digitlist-sum>)
  - [func (d DigitList) ValueOfDigits(n []int64) (ret int64)](<#func-digitlist-valueofdigits>)
- [type Divisors](<#type-divisors>)
  - [func NewDivisors(n int64) *Divisors](<#func-newdivisors>)
  - [func (d *Divisors) HasValue() bool](<#func-divisors-hasvalue>)
  - [func (d *Divisors) NextValue() int64](<#func-divisors-nextvalue>)
- [type Factoradic](<#type-factoradic>)
  - [func NewFactoradic(n int64) *Factoradic](<#func-newfactoradic>)
  - [func (f Factoradic) Permutation(n int64) []int64](<#func-factoradic-permutation>)
- [type IntModM](<#type-intmodm>)
  - [func NewIntModM(m int64) *IntModM](<#func-newintmodm>)
  - [func (m IntModM) Cmp(a int64, b int64) int](<#func-intmodm-cmp>)
  - [func (m IntModM) Diff(x *int64, a int64, b int64)](<#func-intmodm-diff>)
  - [func (m IntModM) Div(x *int64, a int64, b int64)](<#func-intmodm-div>)
  - [func (m IntModM) Let(x *int64, a int64)](<#func-intmodm-let>)
  - [func (m IntModM) Mul(x *int64, a int64, b int64)](<#func-intmodm-mul>)
  - [func (m IntModM) Neg(x *int64, a int64)](<#func-intmodm-neg>)
  - [func (m IntModM) Set(x *int64, a int64)](<#func-intmodm-set>)
  - [func (m IntModM) Sum(x *int64, a int64, b int64)](<#func-intmodm-sum>)
- [type Integer](<#type-integer>)
- [type Iterator](<#type-iterator>)
- [type PrimeFactorization](<#type-primefactorization>)
  - [func NewPrimeFactorization(n int64) *PrimeFactorization](<#func-newprimefactorization>)
  - [func (f PrimeFactorization) HasValue() bool](<#func-primefactorization-hasvalue>)
  - [func (f *PrimeFactorization) NextValue() (int64, int64)](<#func-primefactorization-nextvalue>)
- [type RationalFraction](<#type-rationalfraction>)
  - [func NewRationalFraction(a int64, b int64) *RationalFraction](<#func-newrationalfraction>)
  - [func NextFareySequence(f []RationalFraction, n int64) []RationalFraction](<#func-nextfareysequence>)
  - [func (r *RationalFraction) NextMantissaDigit(base int64) int64](<#func-rationalfraction-nextmantissadigit>)
- [type RationalSurd](<#type-rationalsurd>)
  - [func (s *RationalSurd) IntFloor(d *RationalSurdValue) int64](<#func-rationalsurd-intfloor>)
  - [func (s *RationalSurd) Invert(d *RationalSurdValue)](<#func-rationalsurd-invert>)
  - [func (s *RationalSurd) NextCFConvergent(cur []RationalFraction, a int64) []RationalFraction](<#func-rationalsurd-nextcfconvergent>)
  - [func (s *RationalSurd) NextCFTerm(d *RationalSurdValue) int64](<#func-rationalsurd-nextcfterm>)
- [type RationalSurdValue](<#type-rationalsurdvalue>)


## Constants

```go
const MaxInt64 int64 = int64((^uint64(0)) >> 1)
```

```go
const MaxSqrtInt64 int64 = 3037000499
```

```go
const MaxSquareInt64 int64 = MaxSqrtInt64 * MaxSqrtInt64
```

## func C

```go
func C(n int64, k int64) int64
```

n Choose k https://cp-algorithms.com/combinatorics/binomial-coefficients.html

## func GCD

```go
func GCD(a, b int64) int64
```

## func IntSolveQuadradic

```go
func IntSolveQuadradic(a, b, c int64) (ret []int64)
```

Return integer roots of \`ax^2\+bx\+c\` as a slice\, largest root first

## func IntSqrt

```go
func IntSqrt(n int64) int64
```

https://en.wikipedia.org/wiki/Integer_square_root

## func InverseModN

```go
func InverseModN(a, n int64) int64
```

Modular inverse \(or 0 if no inverse\)

## func IsPrime

```go
func IsPrime(x int64) bool
```

Basic primality test

## func LCM

```go
func LCM(a, b int64) int64
```

## func NewRationalSurd

```go
func NewRationalSurd(D int64) (*RationalSurd, *RationalSurdValue)
```

## func NextCFConvergentOf

```go
func NextCFConvergentOf[V any](i Integer[V], cur []V, a V) []V
```

Generic Next convergent: input is Integer slce \[p0\,q0\,p1\,q1\]

## func Pow

```go
func Pow(x int64, n int64) int64
```

https://en.wikipedia.org/wiki/Exponentiation_by_squaring

## func PowOf

```go
func PowOf[V any](f Integer[V], x V, n int64) V
```

Generic Pow\(\) function for an Integer\[V\] interface

## func Reduce

```go
func Reduce(i Iterator, f func(int64, int64) int64, start int64) int64
```

A generic \`Reduce\(\)\` to int64 method for Iterator's

## func Totient

```go
func Totient(n int64) int64
```

## type BigInt

Integer\[big\.Int\]

```go
type BigInt struct {
}
```

### func NewBigInt

```go
func NewBigInt() *BigInt
```

### func \(BigInt\) Cmp

```go
func (bv BigInt) Cmp(a big.Int, b big.Int) int
```

### func \(BigInt\) Diff

```go
func (bb BigInt) Diff(x *big.Int, a big.Int, b big.Int)
```

### func \(BigInt\) Div

```go
func (bb BigInt) Div(x *big.Int, a big.Int, b big.Int)
```

### func \(BigInt\) Let

```go
func (b BigInt) Let(x *big.Int, a int64)
```

### func \(BigInt\) Mul

```go
func (bb BigInt) Mul(x *big.Int, a big.Int, b big.Int)
```

### func \(BigInt\) Neg

```go
func (b BigInt) Neg(x *big.Int, a big.Int)
```

### func \(BigInt\) Set

```go
func (b BigInt) Set(x *big.Int, a big.Int)
```

### func \(BigInt\) Sum

```go
func (bb BigInt) Sum(x *big.Int, a big.Int, b big.Int)
```

## type Combinations

Iterate through the combinations https://en.wikipedia.org/wiki/Combination#Enumerating_k-combinations

```
c := NewCombinations(n, k)

for ; c.HasValue(); c.NextValue() {
	v := c.GetValue()
}
```

```go
type Combinations struct {
    // contains filtered or unexported fields
}
```

### func NewCombinations

```go
func NewCombinations(n, k int64) *Combinations
```

### func \(\*Combinations\) GetValue

```go
func (c *Combinations) GetValue() []int64
```

### func \(\*Combinations\) HasValue

```go
func (c *Combinations) HasValue() bool
```

### func \(\*Combinations\) NextValue

```go
func (c *Combinations) NextValue()
```

## type DigitList

Manage integers as lists of digits with a given base\.

This is basically an inefficent BigInt\, intended as an exercise in the basic algorithms of digit based arithmetic\, and for problems which primarily invove digit manipulation for other reasons\.

Conforms to Integer interface

```go
type DigitList struct {
    // contains filtered or unexported fields
}
```

### func NewDigitList

```go
func NewDigitList(base int64) *DigitList
```

Constructor for DigitList

### func \(DigitList\) Cmp

```go
func (d DigitList) Cmp(a []int64, b []int64) int
```

Comparison: a X b \(\-1 means \<; 0 means ==; 1 means \>\)

### func \(DigitList\) Diff

```go
func (d DigitList) Diff(x *[]int64, a []int64, b []int64)
```

x = a \- b

### func \(DigitList\) Digits

```go
func (d DigitList) Digits(n int64) []int64
```

Create digit list representation of n\.

### func \(DigitList\) Div

```go
func (d DigitList) Div(x *[]int64, a []int64, b []int64)
```

x = a / b \(integer division\)

BUG\(mlitwin\): Not actually implemented\.

### func \(DigitList\) Histogram

```go
func (d DigitList) Histogram(n []int64) (ret []int64)
```

Histogram of digit values

### func \(DigitList\) Let

```go
func (d DigitList) Let(x *[]int64, a int64)
```

x = a \(int64\)

### func \(DigitList\) Mul

```go
func (d DigitList) Mul(x *[]int64, a []int64, b []int64)
```

x = a \* b

### func \(DigitList\) Neg

```go
func (d DigitList) Neg(x *[]int64, a []int64)
```

x = \-a

### func \(DigitList\) Set

```go
func (d DigitList) Set(x *[]int64, a []int64)
```

x = a

### func \(DigitList\) Sum

```go
func (d DigitList) Sum(x *[]int64, a []int64, b []int64)
```

x = a \+ b

### func \(DigitList\) ValueOfDigits

```go
func (d DigitList) ValueOfDigits(n []int64) (ret int64)
```

Compute integer value represented by list of digits\.

## type Divisors

Divisors implements an Iterator through the divisors of n

```go
type Divisors struct {
    // contains filtered or unexported fields
}
```

### func NewDivisors

```go
func NewDivisors(n int64) *Divisors
```

### func \(\*Divisors\) HasValue

```go
func (d *Divisors) HasValue() bool
```

### func \(\*Divisors\) NextValue

```go
func (d *Divisors) NextValue() int64
```

## type Factoradic

A factoradic base number\, supporting conversion to a permutation\. https://en.wikipedia.org/wiki/Factorial_number_system

```go
type Factoradic struct {
    Value  int64
    Digits []int64
}
```

### func NewFactoradic

```go
func NewFactoradic(n int64) *Factoradic
```

Create the factoradic representation of n\.

### func \(Factoradic\) Permutation

```go
func (f Factoradic) Permutation(n int64) []int64
```

Convert the factoradic to a permutation of n items\.

## type IntModM

Integer Modulo m\, represented in an int64

```go
type IntModM struct {
    // contains filtered or unexported fields
}
```

### func NewIntModM

```go
func NewIntModM(m int64) *IntModM
```

### func \(IntModM\) Cmp

```go
func (m IntModM) Cmp(a int64, b int64) int
```

### func \(IntModM\) Diff

```go
func (m IntModM) Diff(x *int64, a int64, b int64)
```

### func \(IntModM\) Div

```go
func (m IntModM) Div(x *int64, a int64, b int64)
```

### func \(IntModM\) Let

```go
func (m IntModM) Let(x *int64, a int64)
```

### func \(IntModM\) Mul

```go
func (m IntModM) Mul(x *int64, a int64, b int64)
```

### func \(IntModM\) Neg

```go
func (m IntModM) Neg(x *int64, a int64)
```

### func \(IntModM\) Set

```go
func (m IntModM) Set(x *int64, a int64)
```

### func \(IntModM\) Sum

```go
func (m IntModM) Sum(x *int64, a int64, b int64)
```

## type Integer

generic "Integer" operations Not a mathematics integer\, but a computer science integer \- basically has addition/subtraction/multiplication/divistion

```go
type Integer[V any] interface {
    Let(x *V, a int64)
    Set(x *V, a V)
    Neg(x *V, a V)
    Sum(x *V, a V, b V)
    Diff(x *V, a V, b V)
    Mul(x *V, a V, b V)
    Div(x *V, a V, b V)
    Cmp(a V, b V) int
}
```

## type Iterator

Basic abstract iterator of int64's with a \`HasValue\(\)\` / \`NextValue\(\)\` interface

```go
type Iterator interface {
    HasValue() bool
    NextValue() int64
}
```

## type PrimeFactorization

```go
type PrimeFactorization struct {
    // contains filtered or unexported fields
}
```

### func NewPrimeFactorization

```go
func NewPrimeFactorization(n int64) *PrimeFactorization
```

### func \(PrimeFactorization\) HasValue

```go
func (f PrimeFactorization) HasValue() bool
```

### func \(\*PrimeFactorization\) NextValue

```go
func (f *PrimeFactorization) NextValue() (int64, int64)
```

## type RationalFraction

A RationalFraction A/B supporting extraction of arbitrary base \`NextMantissaDigit\(\)\`

```go
type RationalFraction struct {
    A   int64
    B   int64
}
```

### func NewRationalFraction

```go
func NewRationalFraction(a int64, b int64) *RationalFraction
```

### func NextFareySequence

```go
func NextFareySequence(f []RationalFraction, n int64) []RationalFraction
```

Produce the n'th Farey sequence from the \(n\-1\)th https://en.wikipedia.org/wiki/Farey_sequence

You can pass nil to start things off:

```
NextFareySequence(nil, 1)
```

And pass a slice of the previous sequence\, if all you are interested in is expanding that subsequence\.

### func \(\*RationalFraction\) NextMantissaDigit

```go
func (r *RationalFraction) NextMantissaDigit(base int64) int64
```

Assuming proper fraction\, spit out the next digit base whatever\, and advance to to remainder

## type RationalSurd

Operations on \(a\+b\*sqrt\(D\)\)/c

```go
type RationalSurd struct {
    D int64 // surd
    // contains filtered or unexported fields
}
```

### func \(\*RationalSurd\) IntFloor

```go
func (s *RationalSurd) IntFloor(d *RationalSurdValue) int64
```

floor\(d\)

### func \(\*RationalSurd\) Invert

```go
func (s *RationalSurd) Invert(d *RationalSurdValue)
```

1/d

### func \(\*RationalSurd\) NextCFConvergent

```go
func (s *RationalSurd) NextCFConvergent(cur []RationalFraction, a int64) []RationalFraction
```

Next convergent for continued fraction start with an empty \[\]RationalFraction slice\. Convergent will be the last in the returned slice\. Slice is kept for recurrence relation\.

### func \(\*RationalSurd\) NextCFTerm

```go
func (s *RationalSurd) NextCFTerm(d *RationalSurdValue) int64
```

Next term in continued fraction

## type RationalSurdValue

Instance of \(a\+b\*sqrt\(D\)\)/c

```go
type RationalSurdValue struct {
    // contains filtered or unexported fields
}
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
